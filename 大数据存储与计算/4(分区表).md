#### 外部表和内部表

#### 内部表

- **数据由 Hive 全权管理**
- 删除表时，**数据和元数据都会删除**
- 数据存储在 Hive 默认的 warehouse 目录中
- 适合临时数据或测试数据

（创建时默认为内部表）

```sql
CREATE TABLE managed_student (
    id int,
    name string
);
```

#### 外部表

- **数据由外部系统管理**
- 删除表时，**只删除元数据，不删除实际数据**
- 数据位置可以自定义
- 适合与其他工具共享数据

```sql
CREATE EXTERNAL TABLE external_student (
    id int,
    name string
)
LOCATION '/user/hive/student_data';
```

| 特性         | 内部表             | 外部表             |
| :----------- | :----------------- | :----------------- |
| **数据管理** | Hive 管理          | 外部系统管理       |
| **删除表时** | 删除元数据+数据    | 只删除元数据       |
| **数据位置** | Hive 仓库目录      | 可自定义位置       |
| **使用场景** | 临时数据、中间结果 | 共享数据、重要数据 |

**重要数据一定要用外部表，防止误删**

### 数据存储位置

  Hive会为每个数据库创建一个目录。数据库中的表将会以该数据库目录的子目录形式存储。有一个例外就是DEFAULT数据库中的表，DEFAULT数据库没有存储目录，因此DEFAULT数据库中的表将存储在/user/hive/warehouse目录下。当创建数据库TestDB时，Hive将会对应地创建一个HDFS目录/use/hive/warehouse/TestDB.db

 ![image-20251130210348784](C:\Users\赵兴理\AppData\Roaming\Typora\typora-user-images\image-20251130210348784.png)

#### 修改表名

```
alter table student rename to stu;
```

#### 增加列

```sql 
alter table stu add columns(sex string, birthday string)
```

### 分区

#### 静态分区

##### 创建分区表

```sql
create table customer_partition(name string, age int)
partitioned by(sex string) --根据性别进行分区
row format delimited 
fields terminated by '\t’;
```

##### 将数据加载入分区

```sql
load data local inpath '/usr/hivetestdata/customer.txt' into table customer_partition partition(sex='man');
```

##### 存储结构

```
hdfs dfs -ls /user/hive/warehouse/customer_partition
```

![image-20251130211833616](C:\Users\赵兴理\AppData\Roaming\Typora\typora-user-images\image-20251130211833616.png)

#### 根据多个属性进行分区

```sql
create table customer_partition_multi(name string, age int) 
          partitioned by(sex string, native string)
          row format delimited 
          fields terminated by '\t';
```

##### 加载数据

```sql
load data local inpath '/usr/hivetestdata/customer.txt' into table customer_partition_multi partition(sex='man',native='gansu');
```

##### 存储结构

```sql
hdfs dfs -ls /user/hive/warehouse/customer_partition_multi/sex=man/native=gansu
```

### 动态分区

#### 1.需要准备源数据表，不能直接使用load data命令

```
-- 创建源表（包含分区字段sex）
CREATE TABLE customer_source (
    id INT,
    name STRING,
    age INT,
    sex STRING  -- 这个字段将作为分区字段
)
ROW FORMAT DELIMITED
FIELDS TERMINATED BY ',';

-- 加载数据到源表
LOAD DATA LOCAL INPATH '/usr/hivetestdata/customer.txt' INTO TABLE customer_source;

```

#### 2.创建动态分区表

```
CREATE TABLE customer_partition (
    id INT,
    name STRING,
    age INT
)
PARTITIONED BY (sex STRING);
```

#### 3.启动动态分区并插入数据

```
-- 启用动态分区
SET hive.exec.dynamic.partition = true;//打开动态分区功能
SET hive.exec.dynamic.partition.mode = nonstrict;/这个字段默认值为strict, 要求分区字段至少有一个是静态分区，指定分区值。nostrict允许所有字段都是动态分区
set hive.exec.max.dynamic.partitions.pernode=1000;//每个结点允许创建的最大动态分区个数
动态分区和静态分区的最大区别是导入数据时不需要指定分区的值。

-- 动态分区插入（核心步骤）
INSERT OVERWRITE TABLE customer_partition
PARTITION (sex)
SELECT 
    id,
    name, 
    age,
    sex  -- 分区字段必须放在SELECT的最后
FROM customer_source;
```

### 动态分区和静态分区混合使用

```sql
create table partition_table001(  
    name string,  --姓名
    ip string  --ip)  
partitioned by (dt string, ht string)  --data, hour
row format delimited fields terminated by "\t”
```

#### (1）使用静态分区静态分区用select插入数据时，不需要查找分区属性

```sql
create table if not exists partition_table002 like partition_table001; 
insert overwrite table partition_table002
partition (dt='20150617', ht='00’) 0
select name, ip from partition_table001 where dt='20150617' and ht='00’;
                   --如果一天24小时的数据，就必须执行上面的代码24次，每次录入一个ht. 
```

#### (2）使用动态分区

```sql
insert overwrite table partition_table002
partition (dt, ht) 
select * from partition_table001 
-- Select 出最后两个值，然后填到dt和ht,然后再把剩下的数据录入到对应的位置
```

#### （3）动态分区和静态分区组合

```sql
insert overwrite table partition_table002 
partition(dt=‘2022-03-15’,ht)
Select name, ip ht from partition_table001
-- 静态分区的数据由dt指定，动态分区的数据由select得到。
```

### 总结：

```sql
--（1）创建分区表时分区属性sex和native单独指出
create table customer_partition_1(name string, age int)        
       partitioned by(sex string, native string)
       row format delimited
       fields terminated by '\t’;
--（2）创建分区表时用partitioned by，录入数据时用partition
   insert overwrite table customer_partition_1 partition(sex, native)

```



### 为什么要使用 Hive? hive 的优缺点？Hive的作用是什么?

1. 提供类SQL查询，容易上手，开发方便；
2. 封装了很多方法，尽量避免了开发MapReduce程序，减少成本；
3. 适用于处理大规模数据，小数据的处理没有优势；
4. 执行延迟较高，适合用于数据分析，不适合对时效性要求较高的场景。

### 说下Hive是什么? 跟数据库区别?

- hive 是用于大数据分析处理的工具，存储基于 HDFS,计算基于 MapReduce 或 Spark，提供类 SQL 查询。

- hive 除了可以通过类 SQL 查询这一点和数据库有点关系外，其它基本没啥关联。

### 分桶表

预设配置

```sql
set hive.strict.checks.bucketing = false;
set hive.mapred.mode = nonstrict;
set hive.enforce.bucketing = true;
set mapreduce.job.reduces = -1;
```



#### 创建分桶表

```
---创建分桶表dept_buck：根据deptno分成4个桶
create table if not exists dept_buck(
    deptno int,
    dname string
)
clustered by(deptno)
into 4 buckets
row format delimited
fields terminated by ',';

drop table temp_dept_buck;
----创建中间表temp_dept_buck：与dept_buck表结构一致
create table if not exists temp_dept_buck(
    deptno int,
    dname string
)
row format delimited
fields terminated by ',';


---通过load加载数据到temp_dept_buck中间表
load data local inpath '/root/dept.txt' into table temp_dept_buck;


---通过insert插入数据至dept_buck分桶表
insert into table dept_buck
select * from temp_dept_buck;

---抽样查询dept_buck表数据：从第1个桶中开始抽取，相隔4个桶再次抽取，抽样的列为deptno
select * from dept_buck
tablesample(bucket 1 out of 4 on deptno);
```



